\documentclass[11pt]{article}

\usepackage[linkcolor=blue,urlcolor=blue,colorlinks=true]{hyperref}
\usepackage[margin=1in]{geometry}

\title{\textbf{Project Report}}
\author{Logan Gill, Brielle Hoff}
\date{}

\addtolength{\textheight}{3cm}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Overview}
For our final project, we decided to build, analyze, and visualize a tool
to facilitate easier user interaction with the crafting recipes in
\href{https://en.wikipedia.org/wiki/Minecraft}{Minecraft}.
In order to accomplish this, we created a PostgreSQL script that processes
the recipe data in the game's built-in format (JSON) and produces a normalized
relational database. Using this database, we built an application with which
a user may create a plan for a Minecraft project and determine which resources
are needed to create all necessary items. Additionally, we created a
visualization in the form of a graph which contains the relationships
between every recipe\footnote{There are some pathological cases which are
too strange to include.} and their relevant items.

\section{Dataset --- Interrelated Tables}

To construct our database, our script is run against one's official copy of Minecraft.
This assumes the user has Minecraft installed at its standard location (\texttt{\~/.minecraft}).
To acquire a copy, visit \href{https://www.minecraft.net/}{www.minecraft.net}.
To the extent required by law, all copyrighted data is copyright Mojang AB.
The visualization and application presented in this report were produced with data from
Minecraft 1.21.10, but our script works with some earlier versions.

\noindent The dataset that we constructed contains, in addition to several mostly-trivial
tables used for data integrity purposes, three substantially interesting
tables: \texttt{recipe}, \texttt{recipe\_ingredient}, and \texttt{item\_tag}.
The \texttt{recipe} table (1422 rows) represents each recipe in the game; the
\texttt{recipe\_ingredient} table (5083 rows) represents each item in each recipe,
including metadata about the item's usage; the \texttt{item\_tag} table (2828 rows)
represents the game's ability to use classes of items instead of individual
items in recipes. We believe this is a sufficiently complex and interesting dataset
for this project.

\section{Application --- Software Development}

\section{Outputs}

\subsection{Data Loading and Cleaning}

\subsubsection{Source Data}

Minecraft stores its recipes as a large collection of JSON files. Each file represents
a single recipe in the game, and may come in one of a variety of formats.
Recipes typically include an input section and an output section. The output section
takes on a mostly consistent format (including the number and identity of the produced item),
but the input section differs dramatically depending on the ``type'' of the recipe.

\noindent The most well-known recipe type is the ``shaped crafting`` recipe. Here, input
items are placed in particular cells of a grid. Recipe files of this type contain a \texttt{key}
attribute, which maps ASCII characters to items or tags, and a \texttt{pattern} attribute,
which contains an array of strings forming a keyed representation of the recipe in ASCII art.

\noindent Many other recipes are ``shapeless``, meaning items may be placed in any order.
The input format is correspondingly simple, providing a flat array of ingredients.

\noindent Our database includes 6 other recipe types for things like cooking or breaking
down items at various workstations. Recipes of these types map a single input to a single output,
but with slightly different formats.

\noindent A few additional recipe types exist, but mostly represent special cases in the game's code,
and we do not include these in this project.

\subsubsection{Data Cleaning}

We start by putting all JSON records into two files in CSV format (using \texttt{src/mk-csv.sh}), with
one CSV row per JSON file. This is the extent of processing done outside SQL. From here, at the request of our instructor, we proceed
with data processing entirely in SQL. The CSV files are loaded into staging tables and SQL
JSON operators are used to gradually munge the data into a usable format (using \texttt{src/load.sql}).

\noindent While a few tables are trivial to build, some require more complex processing.
A recursive CTE was required to expand tags (tags may contain other tags hierarchically
with arbitrary depth). Additionally, some recipes eschew the tag system and store ingredients
as arrays of items where an item or tag would normally be expected. We address this problem
by introducing synthetic tags, which we fill with the relevant items, and updating troublesome
records accordingly. Finally, converting the ASCII-art format used in shaped recipes (which
is likely used to make recipes easily human-editable) to our internal format required
some lateral thinking.

\subsection{Database Schema Design}

\subsection{Data Visualization}

\subsection{Software Development}

\section{Conclusion}

\end{document}
