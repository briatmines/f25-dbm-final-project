\documentclass[11pt]{article}

\usepackage[linkcolor=blue,urlcolor=blue,colorlinks=true]{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage[skip=10pt plus 1pt,indent=0pt]{parskip}
\usepackage{graphicx}

\title{\textbf{Project Report}}
\author{Logan Gill, Brielle Hoff}
\date{2025-12-10}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Overview}
For our final project, we decided to build, analyze, and visualize a tool
to facilitate easier user interaction with the crafting recipes in
\href{https://en.wikipedia.org/wiki/Minecraft}{Minecraft}.
In order to accomplish this, we created a PostgreSQL script that processes
the recipe data in the game's built-in format (JSON) and produces a normalized
relational database. Using this database, we built an application with which
a user may create a plan for a Minecraft project and determine which resources
are needed to create all necessary items. Additionally, we created a
visualization in the form of a graph which contains the relationships
between every recipe\footnote{There are some pathological cases which are
too strange to include.} and their relevant items.

All relevant project files are included either in
\href{https://github.com/briatmines/f25-dbm-final-project}{our project repository}
or are generated by scripts in the repository from an official copy of Minecraft.

\section{Dataset --- Interrelated Tables}

To construct our database, our script is run against one's official copy of Minecraft.
This assumes the user has Minecraft installed at its standard location (\texttt{\~/.minecraft}).
To acquire a copy, visit \href{https://www.minecraft.net/}{www.minecraft.net}.
To the extent required by law, all copyrighted data is copyright Mojang AB.
The visualization and application presented in this report were produced with data from
Minecraft 1.21.10, but our script works with some earlier versions.

The dataset that we constructed contains, in addition to several mostly-trivial
tables used for data integrity purposes, three substantially interesting
tables: \texttt{recipe}, \texttt{recipe\_ingredient}, and \texttt{item\_tag}.
The \texttt{recipe} table (1422 rows) represents each recipe in the game; the
\texttt{recipe\_ingredient} table (5083 rows) represents each item in each recipe,
including metadata about the item's usage (such as placement location); the \texttt{item\_tag} table (2828 rows)
represents the game's ability to use classes of items instead of individual
items in recipes. We believe this is a sufficiently complex and interesting dataset
for this project.

\section{Application --- Software Development}

After constructing the dataset, we created a TUI application with which the recipe tree
may be explored interactively. The application may be found in the \texttt{browser/} folder of our project repository.
It is written using \texttt{psycopg}, a Python PostgreSQL database adapter, and uses
\texttt{curses}, a built-in Python ibrary for writing terminal applications (and a wrapper
around the C library of the same name). It can connect to either the course database or a
local PostgreSQL server containing the extracted data.

Using this application, the user may create and edit "plans" containing a set of Minecraft items
and quantities, and can then explore the space of ways to craft that set of items.
For example, one might create a plan for an in-game house, which would consist of
all of the block types present in the build (wood, brick, etc.) along with the total number of each one used.
The application would then present a tree structure with a node for each item.
Any item may be left as-is, if the user already posesses enough of that item, or expanded so that a recipe
(if available) to produce that item may be selected. Upon selection, the recipe would then expand to its constituent items.
This process may be repeated, hierarchically, as needed.
Required total quantities are tracked throughout. Items may also be split into multiple
identical nodes whose count sum to that of the original, which is useful if the user
wants to be able to acquire an item through a combination of recipes. After each change to the tree,
the application updates a list of the base items (corresponding to leaf nodes of the tree),
as well as items that will be left over after crafting the set. This could be very useful to
Minecraft players who need to know what resources to gather in what quantities in order to
successfully build their ideas.

Once created, user plans can be saved to the database for further exploration at a later date.

\section{Outputs}

\subsection{Data Loading and Cleaning}

\subsubsection{Source Data}

Minecraft stores its recipes as a large collection of JSON files. Each file represents
a single recipe in the game, and may come in one of a variety of formats.
Recipes typically include an input section and an output section. The output section
takes on a mostly consistent format (including the number and identity of the produced item),
but the input section differs dramatically depending on the ``type'' of the recipe.

The most well-known recipe type is the ``shaped crafting'' recipe. Here, input
items are placed in particular cells of a grid. Recipe files of this type contain a \texttt{key}
attribute, which maps ASCII characters to items or tags, and a \texttt{pattern} attribute,
which contains an array of strings forming a keyed representation of the recipe in ASCII art.

Many other recipes are ``shapeless'', meaning items may be placed in any order.
The input format is correspondingly simple, providing a flat array of ingredients.

Our database includes 6 other recipe types for things like cooking or breaking
down items at various workstations. Recipes of these types map a single input to a single output,
but with slightly different formats.

A few additional recipe types exist, but mostly represent special cases in the game's code,
and we do not include these in this project.

\subsubsection{Data Cleaning}

We start by putting all JSON records into two files in CSV format (using \texttt{src/mk-csv.sh}), with
one CSV row per JSON file. This is the extent of processing done outside SQL. From here, at the request of our instructor, we proceed
with data processing entirely in SQL. The CSV files are loaded into staging tables and SQL
JSON operators are used to gradually munge the data into a usable format (using \texttt{src/load.sql}).

While a few tables are trivial to build, some require more complex processing.
A recursive CTE was required to expand tags (tags may contain other tags hierarchically
with arbitrary depth). Additionally, some recipes eschew the tag system and store ingredients
as arrays of items where an item or tag would normally be expected. We address this problem
by introducing synthetic tags, which we fill with the relevant items, and updating troublesome
records accordingly. Finally, converting the ASCII-art format used in shaped recipes (which
is likely used to make recipes easily human-editable) to our internal format required
some lateral thinking.

\subsection{Database Schema Design}

\includegraphics[width=10cm]{./er-diagram.png}

One of our first tasks of the project was planning our database schema.
There are three primary entity types here, as illustrated above: items, recipes, and tags.
These relationships are many-to-many in general, so the edge labels are omitted for brevity.
Items are related to tags (a tag can contain any number of items and an item can belong
to any number of tags); recipes always have a single output item (with a quantity) and
a number of positioned inputs which can be items or tags; and recipes have various attributes
which are used by the game and shown for informational purposes in the application
(category, type, and group). We generate a few additional single-column
tables which serve as enumerations for certain attributes. For example, there is a \texttt{recipe\_group}
table which the \texttt{recipe\_group} attribute on the \texttt{recipe} table references as a foreign key.
The same applies to recipe categories. Most other key constraints are fairly self-explanatory
given the entity relationships.

We chose to do quite a bit of normalization here. This increased the complexity of the data loading step,
but made future processing and application development much easier. For example, native tags are allowed
to reference other tags, but we chose to flatten these relationships while building the table. This has
practical implications, as applications can find all items in a tag with one query; without such flattening,
the tag entity would have a relationship to itself and applications would likely be doing a lot of repeated
work without much benefit.

\subsection{Data Visualization}

In order to visualize this recipe data we wrote a program which
performs a physics-like simulation to untangle a graph of the data into
recognizable structures (see \texttt{visualizer/}).

To use it, first run \texttt{export.sql} to pull the data out of the
database into a couple of flat JSON files (still in our normalized
format) spin up a simple http server (e.g. with
\texttt{python3 -m http.server}) and then navigate to
\texttt{/visualize.html} (Requires a fairly powerful computer and a
relatively modern browser).

The output of that program looks something like this:
(N.B. the randomness in the program means the exact graph is different
each time)

\begin{center}
\includegraphics[width=10cm]{./full-graph-small.png}

\includegraphics[width=10cm]{./subgraph.png}

Fig 1. The complete visualization and a cropped portion to show detail.
\end{center}

In this graph, blue circle nodes represent items, red teardrop nodes
recipes (with the direction pointing at the recipe's output, and green
diamond nodes tags.
The thickness of edges is proportional to the number of items involved.


\subsection{Software Development}

As mentioned earlier in this report, the source code for our application can be found in our
\href{https://github.com/briatmines/f25-dbm-final-project}{project repository}.

\begin{center}
\includegraphics[width=10cm]{./browser-demo.png}

Fig 2. A demo of the TUI application in action. This user already possesses 3 \texttt{minecraft:cherry\_planks},
so they created a split node,
and has now discovered that they need to farm 45 \texttt{minecraft:bamboo}
in order to complete this build.
\end{center}

Most tree nodes make database queries when expanded for the first time.
Making queries lazily like this ensures that the application only stores what it needs to
and is reactive as possible.

For example, the following code is used when a node representing a recipe is expanded to show its input items.

\begin{verbatim}
self.cur.execute('''
    SELECT item, tag
    FROM recipe_ingredient
    WHERE recipe = %s
    ORDER BY position
''', (id,))
self.ingredients = self.cur.fetchall()
\end{verbatim}

Similar code is used in other tree nodes to fetch the required data as needed.
Additionally, the ``planning'' functionality uses similarly simple SQL commands
to insert, modify, and query the tables used to store user-created item lists.
Parameterization is used throughout the program to reduce the risk of SQL injection.

\section{Conclusion}

This was a really fun project that involved a lot of clever tricks,
interesting problem solving, and a good level of complexity.
The dataset is small enough to meaningfully internalize the entire
thing (as many players do) but large and interlinked enough to provide
numerous interesting patterns.
The data processing required to convert the data in its native format
into a format usable for application and analysis posed a fascinating
challenge and we've produced a program that may prove to have genuine
utility.

\end{document}
